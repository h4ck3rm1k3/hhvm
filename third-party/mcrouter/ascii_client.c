
#line 1 "mcrouter/lib/mc/ascii_client.rl"
/* -*- mode: c; -*- */
/* ascii_client.c is built from ascii_client.rl using ragel */

#include <ctype.h>

#include "mcrouter/lib/fbi/debug.h"
#include "mcrouter/lib/mc/_protocol.h"
#include "mcrouter/lib/mc/parser.h"
#include "mcrouter/lib/mc/msg.h"
#include "mcrouter/lib/mc/util.h"

// In libmc.client, only read the first N stats for simplicity of
// implementation. In the future it might make sense to allow an
// arbitrary number of stats, but for now that makes the code far
// easier
#define MAX_NUM_STATS 20

// Are we in the middle of a key being skipped?
#define skipping_key(parser) ((parser)->in_skipped_key &&       \
                              !(parser)->record_skip_key)


#line 26 "mcrouter/lib/mc/ascii_client.c"
static const char _ascii_actions[] = {
	0, 1, 0, 1, 3, 1, 4, 1, 
	5, 1, 9, 1, 11, 1, 12, 1, 
	13, 1, 14, 1, 15, 1, 16, 1, 
	27, 1, 31, 1, 32, 1, 33, 1, 
	34, 1, 35, 1, 36, 1, 37, 1, 
	40, 1, 41, 1, 43, 1, 44, 1, 
	45, 1, 46, 1, 47, 1, 48, 1, 
	49, 1, 50, 1, 51, 1, 52, 1, 
	53, 1, 54, 1, 55, 1, 56, 1, 
	57, 1, 58, 1, 59, 1, 60, 1, 
	61, 1, 62, 1, 63, 1, 64, 2, 
	1, 2, 2, 1, 17, 2, 1, 20, 
	2, 1, 21, 2, 1, 22, 2, 1, 
	23, 2, 1, 24, 2, 1, 25, 2, 
	1, 26, 2, 1, 28, 2, 1, 29, 
	2, 1, 30, 2, 1, 38, 2, 1, 
	39, 2, 1, 42, 2, 18, 0, 2, 
	19, 0, 2, 27, 3, 2, 27, 32, 
	2, 34, 37, 2, 64, 3, 3, 0, 
	1, 42, 3, 1, 2, 3, 3, 1, 
	2, 10, 3, 1, 17, 3, 3, 1, 
	20, 3, 3, 1, 22, 32, 3, 1, 
	24, 3, 3, 1, 25, 3, 3, 1, 
	26, 3, 3, 1, 28, 32, 3, 1, 
	29, 32, 3, 1, 42, 3, 4, 0, 
	1, 42, 3, 4, 1, 2, 10, 64, 
	4, 1, 6, 7, 3, 4, 1, 6, 
	8, 3, 5, 1, 2, 10, 64, 3
	
};

static const short _ascii_key_offsets[] = {
	0, 0, 25, 30, 31, 34, 35, 36, 
	37, 38, 39, 40, 41, 42, 43, 44, 
	45, 47, 48, 50, 53, 57, 59, 60, 
	61, 62, 63, 64, 65, 66, 69, 70, 
	72, 73, 74, 75, 76, 77, 78, 79, 
	80, 81, 82, 83, 84, 85, 89, 93, 
	97, 99, 102, 105, 108, 111, 116, 118, 
	119, 120, 121, 122, 125, 129, 130, 131, 
	132, 133, 137, 141, 143, 144, 145, 146, 
	150, 153, 155, 156, 157, 158, 159, 160, 
	161, 162, 165, 168, 170, 171, 172, 173, 
	174, 183, 192, 194, 197, 199, 202, 204, 
	207, 210, 211, 213, 214, 215, 216, 217, 
	218, 219, 220, 221, 222, 223, 224, 225, 
	228, 233, 234, 237, 240, 241, 244, 245, 
	253, 254, 255, 256, 257, 258, 259, 260, 
	261, 262, 263, 264, 265, 266, 267, 268, 
	269, 270, 272, 273, 274, 275, 276, 277, 
	278, 279, 280, 281, 282, 284, 285, 286, 
	287, 288, 289, 290, 291, 292, 293, 294, 
	296, 297, 299, 302, 306, 308, 309, 311, 
	313, 314, 315, 316, 317, 318, 319, 320, 
	321, 323, 324, 325, 328, 332, 336, 341, 
	343, 344, 345, 346, 347, 353, 354, 355, 
	356, 358, 359, 360, 361, 362, 366, 370, 
	373, 376, 379, 384, 386, 387, 390, 394, 
	395, 396, 397, 398, 399, 400, 402, 404, 
	406, 408, 409, 413, 417, 420, 423, 426, 
	429, 432, 437, 438, 442, 443, 444, 445, 
	446, 447, 448, 451, 454, 455, 456, 457, 
	460, 465, 469, 470, 471, 472, 473, 474, 
	475, 476, 480, 484, 487, 490, 493, 496, 
	499, 502, 505, 510, 511, 513, 514, 515, 
	519, 523, 526, 531, 535, 536, 537, 538, 
	539, 540, 541, 544, 545, 546, 547, 548, 
	552, 558, 564, 569, 570, 571, 572, 573, 
	574, 575, 576, 577, 579, 580, 581, 584, 
	589, 594, 595, 596, 597, 598, 599, 602, 
	608, 609, 610, 612, 616, 622, 628, 629, 
	630, 631, 632, 633, 634, 635, 636, 637, 
	639, 640, 641, 642, 643, 644, 648, 652, 
	656, 658, 661, 662, 663, 664, 665, 666, 
	667, 668, 669, 670, 671, 672, 673, 674, 
	675, 676, 677, 678, 679, 680, 681, 682, 
	685, 686, 687, 688, 689, 690, 691, 692, 
	693, 694, 695, 698, 699, 700, 701, 702, 
	703, 704, 715, 720, 721, 724, 725, 726, 
	727, 728, 729, 730, 731, 732, 733, 734, 
	735, 737, 738, 740, 743, 747, 749, 750, 
	751, 752, 753, 754, 755, 756, 759, 760, 
	762, 763, 764, 765, 766, 767, 768, 769, 
	770, 771, 772, 773, 774, 775, 779, 783, 
	787, 789, 792, 795, 798, 801, 806, 808, 
	809, 810, 811, 812, 815, 819, 820, 821, 
	822, 823, 827, 831, 833, 834, 835, 836, 
	840, 843, 845, 846, 847, 848, 849, 850, 
	851, 852, 855, 858, 860, 861, 862, 863, 
	864, 873, 882, 884, 887, 889, 892, 894, 
	897, 900, 901, 903, 904, 905, 906, 907, 
	908, 909, 910, 911, 912, 913, 914, 915, 
	918, 923, 924, 927, 930, 931, 934, 935, 
	943, 944, 945, 946, 947, 948, 949, 950, 
	951, 952, 953, 954, 955, 956, 957, 958, 
	959, 960, 962, 963, 964, 965, 966, 967, 
	968, 969, 970, 971, 972, 974, 975, 976, 
	977, 978, 979, 980, 981, 982, 983, 984, 
	986, 987, 989, 992, 996, 998, 999, 1001, 
	1003, 1004, 1005, 1006, 1007, 1008, 1009, 1010, 
	1011, 1013, 1014, 1015, 1018, 1022, 1026, 1031, 
	1033, 1034, 1035, 1036, 1037, 1043, 1044, 1045, 
	1046, 1048, 1049, 1050, 1051, 1052, 1056, 1060, 
	1063, 1066, 1069, 1074, 1076, 1077, 1080, 1084, 
	1085, 1086, 1087, 1088, 1089, 1090, 1092, 1094, 
	1108, 1110, 1112, 1113, 1117, 1121, 1124, 1127, 
	1130, 1133, 1136, 1141, 1143, 1144, 1145, 1149, 
	1150, 1151, 1152, 1153, 1154, 1155, 1158, 1161, 
	1162, 1163, 1164, 1167, 1172, 1176, 1177, 1178, 
	1179, 1180, 1181, 1182, 1183, 1187, 1191, 1194, 
	1197, 1200, 1203, 1206, 1209, 1212, 1217, 1218, 
	1220, 1221, 1222, 1226, 1230, 1233, 1238, 1242, 
	1243, 1244, 1245, 1246, 1247, 1248, 1251, 1254, 
	1255, 1256, 1257, 1258, 1262, 1268, 1274, 1279, 
	1280, 1281, 1282, 1283, 1284, 1285, 1286, 1287, 
	1289, 1290, 1291, 1294, 1299, 1304, 1305, 1306, 
	1307, 1308, 1309, 1312, 1318, 1319, 1320, 1322, 
	1326, 1332, 1338, 1339, 1340, 1341, 1342, 1343, 
	1344, 1345, 1346, 1347, 1349, 1350, 1351, 1352, 
	1353, 1354, 1358, 1362, 1366, 1368, 1371, 1372, 
	1373, 1374, 1375, 1376, 1377, 1378, 1379, 1380, 
	1381, 1382, 1383, 1384, 1385, 1386, 1387, 1388, 
	1389, 1390, 1391, 1392, 1395, 1396, 1397, 1398, 
	1399, 1400, 1401, 1402, 1403, 1404, 1405, 1408, 
	1409, 1410, 1411, 1412, 1413, 1414, 1414, 1415, 
	1417, 1418, 1418, 1418, 1419, 1421, 1422
};

static const char _ascii_trans_keys[] = {
	67, 68, 69, 76, 77, 78, 79, 83, 
	86, 97, 99, 100, 101, 102, 103, 105, 
	108, 109, 112, 113, 114, 115, 118, 48, 
	57, 10, 13, 32, 48, 57, 10, 10, 
	13, 32, 76, 73, 69, 78, 84, 95, 
	69, 82, 82, 79, 82, 13, 32, 13, 
	10, 13, 13, 48, 57, 13, 32, 48, 
	57, 13, 32, 13, 69, 76, 69, 84, 
	69, 68, 78, 82, 88, 68, 10, 13, 
	82, 79, 82, 73, 83, 84, 83, 86, 
	65, 76, 85, 69, 32, 32, 127, 0, 
	31, 32, 127, 0, 31, 32, 45, 48, 
	57, 48, 57, 32, 48, 57, 32, 48, 
	57, 32, 48, 57, 32, 48, 57, 10, 
	13, 32, 48, 57, 10, 13, 69, 78, 
	10, 10, 32, 48, 57, 10, 13, 48, 
	57, 69, 84, 65, 32, 32, 127, 0, 
	31, 32, 127, 0, 31, 32, 97, 103, 
	101, 58, 32, 117, 48, 57, 59, 48, 
	57, 32, 101, 120, 112, 116, 105, 109, 
	101, 58, 32, 48, 57, 59, 48, 57, 
	32, 102, 114, 111, 109, 58, 32, 58, 
	117, 48, 57, 65, 70, 97, 102, 46, 
	58, 59, 48, 57, 65, 70, 97, 102, 
	48, 57, 46, 48, 57, 48, 57, 46, 
	48, 57, 48, 57, 59, 48, 57, 59, 
	48, 57, 59, 32, 105, 115, 95, 116, 
	114, 97, 110, 115, 105, 101, 110, 116, 
	58, 32, 48, 57, 10, 13, 32, 48, 
	57, 10, 10, 13, 32, 46, 48, 57, 
	46, 46, 48, 57, 46, 58, 59, 48, 
	57, 65, 70, 97, 102, 110, 107, 110, 
	111, 119, 110, 59, 110, 107, 110, 111, 
	119, 110, 59, 79, 84, 95, 70, 83, 
	79, 85, 78, 68, 84, 79, 82, 69, 
	68, 75, 69, 84, 82, 86, 69, 82, 
	95, 69, 82, 82, 79, 82, 13, 32, 
	13, 10, 13, 13, 48, 57, 13, 32, 
	48, 57, 13, 32, 13, 65, 79, 76, 
	84, 69, 95, 83, 84, 79, 82, 69, 
	68, 10, 13, 10, 32, 127, 0, 32, 
	32, 127, 0, 31, 32, 127, 0, 31, 
	10, 13, 127, 0, 31, 69, 83, 84, 
	65, 84, 10, 10, 13, 32, 127, 0, 
	31, 82, 69, 68, 65, 69, 76, 85, 
	69, 32, 32, 127, 0, 31, 32, 127, 
	0, 31, 32, 48, 57, 32, 48, 57, 
	32, 48, 57, 10, 13, 32, 48, 57, 
	10, 13, 10, 32, 48, 57, 10, 13, 
	48, 57, 82, 83, 73, 79, 78, 32, 
	10, 13, 10, 13, 100, 112, 100, 109, 
	32, 32, 127, 0, 31, 32, 127, 0, 
	31, 32, 48, 57, 32, 48, 57, 32, 
	48, 57, 32, 48, 57, 32, 48, 57, 
	10, 13, 32, 48, 57, 10, 10, 13, 
	32, 110, 111, 114, 101, 112, 108, 121, 
	10, 13, 32, 10, 13, 32, 105, 110, 
	32, 32, 33, 126, 10, 13, 32, 33, 
	126, 10, 13, 32, 126, 112, 101, 110, 
	100, 97, 115, 32, 32, 127, 0, 31, 
	32, 127, 0, 31, 32, 48, 57, 32, 
	48, 57, 32, 48, 57, 32, 48, 57, 
	32, 48, 57, 32, 48, 57, 32, 48, 
	57, 10, 13, 32, 48, 57, 101, 99, 
	108, 114, 32, 32, 127, 0, 31, 32, 
	127, 0, 31, 32, 48, 57, 10, 13, 
	32, 48, 57, 10, 13, 32, 110, 111, 
	114, 101, 112, 108, 121, 10, 13, 32, 
	101, 116, 101, 32, 32, 127, 0, 31, 
	10, 13, 32, 127, 0, 31, 10, 13, 
	32, 110, 48, 57, 10, 13, 32, 48, 
	57, 120, 101, 99, 108, 117, 115, 104, 
	95, 97, 114, 108, 108, 10, 13, 32, 
	10, 13, 32, 48, 57, 10, 13, 32, 
	48, 57, 101, 103, 101, 120, 32, 127, 
	0, 32, 10, 13, 32, 127, 0, 31, 
	101, 116, 32, 115, 32, 127, 0, 31, 
	10, 13, 32, 127, 0, 31, 10, 13, 
	32, 127, 0, 31, 32, 110, 99, 114, 
	101, 97, 115, 101, 45, 103, 115, 101, 
	116, 101, 116, 32, 32, 127, 0, 31, 
	32, 127, 0, 31, 32, 45, 48, 57, 
	48, 57, 32, 48, 57, 101, 116, 97, 
	103, 101, 116, 114, 101, 112, 101, 110, 
	100, 117, 105, 116, 101, 112, 108, 97, 
	99, 101, 101, 104, 116, 116, 117, 116, 
	100, 111, 119, 110, 97, 116, 115, 10, 
	13, 32, 101, 114, 115, 105, 111, 110, 
	67, 68, 69, 76, 77, 78, 79, 83, 
	86, 48, 57, 10, 13, 32, 48, 57, 
	10, 10, 13, 32, 76, 73, 69, 78, 
	84, 95, 69, 82, 82, 79, 82, 13, 
	32, 13, 10, 13, 13, 48, 57, 13, 
	32, 48, 57, 13, 32, 13, 69, 76, 
	69, 84, 69, 68, 78, 82, 88, 68, 
	10, 13, 82, 79, 82, 73, 83, 84, 
	83, 86, 65, 76, 85, 69, 32, 32, 
	127, 0, 31, 32, 127, 0, 31, 32, 
	45, 48, 57, 48, 57, 32, 48, 57, 
	32, 48, 57, 32, 48, 57, 32, 48, 
	57, 10, 13, 32, 48, 57, 10, 13, 
	69, 78, 10, 10, 32, 48, 57, 10, 
	13, 48, 57, 69, 84, 65, 32, 32, 
	127, 0, 31, 32, 127, 0, 31, 32, 
	97, 103, 101, 58, 32, 117, 48, 57, 
	59, 48, 57, 32, 101, 120, 112, 116, 
	105, 109, 101, 58, 32, 48, 57, 59, 
	48, 57, 32, 102, 114, 111, 109, 58, 
	32, 58, 117, 48, 57, 65, 70, 97, 
	102, 46, 58, 59, 48, 57, 65, 70, 
	97, 102, 48, 57, 46, 48, 57, 48, 
	57, 46, 48, 57, 48, 57, 59, 48, 
	57, 59, 48, 57, 59, 32, 105, 115, 
	95, 116, 114, 97, 110, 115, 105, 101, 
	110, 116, 58, 32, 48, 57, 10, 13, 
	32, 48, 57, 10, 10, 13, 32, 46, 
	48, 57, 46, 46, 48, 57, 46, 58, 
	59, 48, 57, 65, 70, 97, 102, 110, 
	107, 110, 111, 119, 110, 59, 110, 107, 
	110, 111, 119, 110, 59, 79, 84, 95, 
	70, 83, 79, 85, 78, 68, 84, 79, 
	82, 69, 68, 75, 69, 84, 82, 86, 
	69, 82, 95, 69, 82, 82, 79, 82, 
	13, 32, 13, 10, 13, 13, 48, 57, 
	13, 32, 48, 57, 13, 32, 13, 65, 
	79, 76, 84, 69, 95, 83, 84, 79, 
	82, 69, 68, 10, 13, 10, 32, 127, 
	0, 32, 32, 127, 0, 31, 32, 127, 
	0, 31, 10, 13, 127, 0, 31, 69, 
	83, 84, 65, 84, 10, 10, 13, 32, 
	127, 0, 31, 82, 69, 68, 65, 69, 
	76, 85, 69, 32, 32, 127, 0, 31, 
	32, 127, 0, 31, 32, 48, 57, 32, 
	48, 57, 32, 48, 57, 10, 13, 32, 
	48, 57, 10, 13, 10, 32, 48, 57, 
	10, 13, 48, 57, 82, 83, 73, 79, 
	78, 32, 10, 13, 10, 13, 97, 99, 
	100, 101, 102, 103, 105, 108, 109, 112, 
	113, 114, 115, 118, 100, 112, 100, 109, 
	32, 32, 127, 0, 31, 32, 127, 0, 
	31, 32, 48, 57, 32, 48, 57, 32, 
	48, 57, 32, 48, 57, 32, 48, 57, 
	10, 13, 32, 48, 57, 10, 13, 10, 
	10, 10, 13, 32, 110, 111, 114, 101, 
	112, 108, 121, 10, 13, 32, 10, 13, 
	32, 105, 110, 32, 32, 33, 126, 10, 
	13, 32, 33, 126, 10, 13, 32, 126, 
	112, 101, 110, 100, 97, 115, 32, 32, 
	127, 0, 31, 32, 127, 0, 31, 32, 
	48, 57, 32, 48, 57, 32, 48, 57, 
	32, 48, 57, 32, 48, 57, 32, 48, 
	57, 32, 48, 57, 10, 13, 32, 48, 
	57, 101, 99, 108, 114, 32, 32, 127, 
	0, 31, 32, 127, 0, 31, 32, 48, 
	57, 10, 13, 32, 48, 57, 10, 13, 
	32, 110, 111, 114, 101, 112, 108, 121, 
	10, 13, 32, 10, 13, 32, 101, 116, 
	101, 32, 32, 127, 0, 31, 10, 13, 
	32, 127, 0, 31, 10, 13, 32, 110, 
	48, 57, 10, 13, 32, 48, 57, 120, 
	101, 99, 108, 117, 115, 104, 95, 97, 
	114, 108, 108, 10, 13, 32, 10, 13, 
	32, 48, 57, 10, 13, 32, 48, 57, 
	101, 103, 101, 120, 32, 127, 0, 32, 
	10, 13, 32, 127, 0, 31, 101, 116, 
	32, 115, 32, 127, 0, 31, 10, 13, 
	32, 127, 0, 31, 10, 13, 32, 127, 
	0, 31, 32, 110, 99, 114, 101, 97, 
	115, 101, 45, 103, 115, 101, 116, 101, 
	116, 32, 32, 127, 0, 31, 32, 127, 
	0, 31, 32, 45, 48, 57, 48, 57, 
	32, 48, 57, 101, 116, 97, 103, 101, 
	116, 114, 101, 112, 101, 110, 100, 117, 
	105, 116, 101, 112, 108, 97, 99, 101, 
	101, 104, 116, 116, 117, 116, 100, 111, 
	119, 110, 97, 116, 115, 10, 13, 32, 
	101, 114, 115, 105, 111, 110, 13, 10, 
	13, 13, 13, 10, 13, 13, 0
};

static const char _ascii_single_lengths[] = {
	0, 23, 3, 1, 3, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	2, 1, 2, 1, 2, 2, 1, 1, 
	1, 1, 1, 1, 1, 3, 1, 2, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 2, 2, 2, 
	0, 1, 1, 1, 1, 3, 2, 1, 
	1, 1, 1, 1, 2, 1, 1, 1, 
	1, 2, 2, 2, 1, 1, 1, 2, 
	1, 2, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 2, 1, 1, 1, 1, 
	3, 3, 0, 1, 0, 1, 0, 1, 
	1, 1, 2, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	3, 1, 3, 1, 1, 1, 1, 2, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 2, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 2, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 2, 
	1, 2, 1, 2, 2, 1, 2, 2, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	2, 1, 1, 1, 2, 2, 3, 2, 
	1, 1, 1, 1, 4, 1, 1, 1, 
	2, 1, 1, 1, 1, 2, 2, 1, 
	1, 1, 3, 2, 1, 1, 2, 1, 
	1, 1, 1, 1, 1, 2, 2, 2, 
	2, 1, 2, 2, 1, 1, 1, 1, 
	1, 3, 1, 4, 1, 1, 1, 1, 
	1, 1, 3, 3, 1, 1, 1, 1, 
	3, 2, 1, 1, 1, 1, 1, 1, 
	1, 2, 2, 1, 1, 1, 1, 1, 
	1, 1, 3, 1, 2, 1, 1, 2, 
	2, 1, 3, 4, 1, 1, 1, 1, 
	1, 1, 3, 1, 1, 1, 1, 2, 
	4, 4, 3, 1, 1, 1, 1, 1, 
	1, 1, 1, 2, 1, 1, 3, 3, 
	3, 1, 1, 1, 1, 1, 1, 4, 
	1, 1, 2, 2, 4, 4, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 2, 
	1, 1, 1, 1, 1, 2, 2, 2, 
	0, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 3, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 3, 1, 1, 1, 1, 1, 
	1, 9, 3, 1, 3, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	2, 1, 2, 1, 2, 2, 1, 1, 
	1, 1, 1, 1, 1, 3, 1, 2, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 2, 2, 2, 
	0, 1, 1, 1, 1, 3, 2, 1, 
	1, 1, 1, 1, 2, 1, 1, 1, 
	1, 2, 2, 2, 1, 1, 1, 2, 
	1, 2, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 2, 1, 1, 1, 1, 
	3, 3, 0, 1, 0, 1, 0, 1, 
	1, 1, 2, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	3, 1, 3, 1, 1, 1, 1, 2, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 2, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 2, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 2, 
	1, 2, 1, 2, 2, 1, 2, 2, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	2, 1, 1, 1, 2, 2, 3, 2, 
	1, 1, 1, 1, 4, 1, 1, 1, 
	2, 1, 1, 1, 1, 2, 2, 1, 
	1, 1, 3, 2, 1, 1, 2, 1, 
	1, 1, 1, 1, 1, 2, 2, 14, 
	2, 2, 1, 2, 2, 1, 1, 1, 
	1, 1, 3, 2, 1, 1, 4, 1, 
	1, 1, 1, 1, 1, 3, 3, 1, 
	1, 1, 1, 3, 2, 1, 1, 1, 
	1, 1, 1, 1, 2, 2, 1, 1, 
	1, 1, 1, 1, 1, 3, 1, 2, 
	1, 1, 2, 2, 1, 3, 4, 1, 
	1, 1, 1, 1, 1, 3, 3, 1, 
	1, 1, 1, 2, 4, 4, 3, 1, 
	1, 1, 1, 1, 1, 1, 1, 2, 
	1, 1, 3, 3, 3, 1, 1, 1, 
	1, 1, 1, 4, 1, 1, 2, 2, 
	4, 4, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 2, 1, 1, 1, 1, 
	1, 2, 2, 2, 0, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 3, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 3, 1, 
	1, 1, 1, 1, 1, 0, 1, 2, 
	1, 0, 0, 1, 2, 1, 0
};

static const char _ascii_range_lengths[] = {
	0, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 0, 0, 
	0, 0, 0, 1, 1, 0, 0, 0, 
	0, 1, 1, 0, 0, 0, 0, 1, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 1, 0, 0, 0, 0, 0, 
	3, 3, 1, 1, 1, 1, 1, 1, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	1, 0, 0, 1, 0, 1, 0, 3, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 1, 1, 0, 
	0, 0, 0, 0, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	1, 1, 1, 0, 0, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 1, 1, 1, 1, 
	1, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	1, 1, 0, 0, 0, 0, 0, 0, 
	0, 1, 1, 1, 1, 1, 1, 1, 
	1, 1, 1, 0, 0, 0, 0, 1, 
	1, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	1, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	1, 0, 0, 0, 0, 0, 1, 1, 
	0, 0, 0, 1, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	1, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 0, 0, 
	0, 0, 0, 1, 1, 0, 0, 0, 
	0, 1, 1, 0, 0, 0, 0, 1, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 1, 0, 0, 0, 0, 0, 
	3, 3, 1, 1, 1, 1, 1, 1, 
	1, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	1, 0, 0, 1, 0, 1, 0, 3, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 1, 1, 0, 
	0, 0, 0, 0, 1, 0, 0, 0, 
	0, 0, 0, 0, 0, 1, 1, 1, 
	1, 1, 1, 0, 0, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 1, 1, 1, 
	1, 1, 1, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 1, 0, 0, 0, 
	0, 0, 0, 0, 1, 1, 1, 1, 
	1, 1, 1, 1, 1, 1, 0, 0, 
	0, 0, 1, 1, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 0, 0, 0, 
	0, 0, 1, 1, 0, 0, 0, 1, 
	1, 1, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 1, 1, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0
};

static const short _ascii_index_offsets[] = {
	0, 0, 25, 30, 32, 36, 38, 40, 
	42, 44, 46, 48, 50, 52, 54, 56, 
	58, 61, 63, 66, 69, 73, 76, 78, 
	80, 82, 84, 86, 88, 90, 94, 96, 
	99, 101, 103, 105, 107, 109, 111, 113, 
	115, 117, 119, 121, 123, 125, 129, 133, 
	137, 139, 142, 145, 148, 151, 156, 159, 
	161, 163, 165, 167, 170, 174, 176, 178, 
	180, 182, 186, 190, 193, 195, 197, 199, 
	203, 206, 209, 211, 213, 215, 217, 219, 
	221, 223, 226, 229, 232, 234, 236, 238, 
	240, 247, 254, 256, 259, 261, 264, 266, 
	269, 272, 274, 277, 279, 281, 283, 285, 
	287, 289, 291, 293, 295, 297, 299, 301, 
	304, 309, 311, 315, 318, 320, 323, 325, 
	331, 333, 335, 337, 339, 341, 343, 345, 
	347, 349, 351, 353, 355, 357, 359, 361, 
	363, 365, 368, 370, 372, 374, 376, 378, 
	380, 382, 384, 386, 388, 391, 393, 395, 
	397, 399, 401, 403, 405, 407, 409, 411, 
	414, 416, 419, 422, 426, 429, 431, 434, 
	437, 439, 441, 443, 445, 447, 449, 451, 
	453, 456, 458, 460, 463, 467, 471, 476, 
	479, 481, 483, 485, 487, 493, 495, 497, 
	499, 502, 504, 506, 508, 510, 514, 518, 
	521, 524, 527, 532, 535, 537, 540, 544, 
	546, 548, 550, 552, 554, 556, 559, 562, 
	565, 568, 570, 574, 578, 581, 584, 587, 
	590, 593, 598, 600, 605, 607, 609, 611, 
	613, 615, 617, 621, 625, 627, 629, 631, 
	634, 639, 643, 645, 647, 649, 651, 653, 
	655, 657, 661, 665, 668, 671, 674, 677, 
	680, 683, 686, 691, 693, 696, 698, 700, 
	704, 708, 711, 716, 721, 723, 725, 727, 
	729, 731, 733, 737, 739, 741, 743, 745, 
	749, 755, 761, 766, 768, 770, 772, 774, 
	776, 778, 780, 782, 785, 787, 789, 793, 
	798, 803, 805, 807, 809, 811, 813, 816, 
	822, 824, 826, 829, 833, 839, 845, 847, 
	849, 851, 853, 855, 857, 859, 861, 863, 
	866, 868, 870, 872, 874, 876, 880, 884, 
	888, 890, 893, 895, 897, 899, 901, 903, 
	905, 907, 909, 911, 913, 915, 917, 919, 
	921, 923, 925, 927, 929, 931, 933, 935, 
	939, 941, 943, 945, 947, 949, 951, 953, 
	955, 957, 959, 963, 965, 967, 969, 971, 
	973, 975, 986, 991, 993, 997, 999, 1001, 
	1003, 1005, 1007, 1009, 1011, 1013, 1015, 1017, 
	1019, 1022, 1024, 1027, 1030, 1034, 1037, 1039, 
	1041, 1043, 1045, 1047, 1049, 1051, 1055, 1057, 
	1060, 1062, 1064, 1066, 1068, 1070, 1072, 1074, 
	1076, 1078, 1080, 1082, 1084, 1086, 1090, 1094, 
	1098, 1100, 1103, 1106, 1109, 1112, 1117, 1120, 
	1122, 1124, 1126, 1128, 1131, 1135, 1137, 1139, 
	1141, 1143, 1147, 1151, 1154, 1156, 1158, 1160, 
	1164, 1167, 1170, 1172, 1174, 1176, 1178, 1180, 
	1182, 1184, 1187, 1190, 1193, 1195, 1197, 1199, 
	1201, 1208, 1215, 1217, 1220, 1222, 1225, 1227, 
	1230, 1233, 1235, 1238, 1240, 1242, 1244, 1246, 
	1248, 1250, 1252, 1254, 1256, 1258, 1260, 1262, 
	1265, 1270, 1272, 1276, 1279, 1281, 1284, 1286, 
	1292, 1294, 1296, 1298, 1300, 1302, 1304, 1306, 
	1308, 1310, 1312, 1314, 1316, 1318, 1320, 1322, 
	1324, 1326, 1329, 1331, 1333, 1335, 1337, 1339, 
	1341, 1343, 1345, 1347, 1349, 1352, 1354, 1356, 
	1358, 1360, 1362, 1364, 1366, 1368, 1370, 1372, 
	1375, 1377, 1380, 1383, 1387, 1390, 1392, 1395, 
	1398, 1400, 1402, 1404, 1406, 1408, 1410, 1412, 
	1414, 1417, 1419, 1421, 1424, 1428, 1432, 1437, 
	1440, 1442, 1444, 1446, 1448, 1454, 1456, 1458, 
	1460, 1463, 1465, 1467, 1469, 1471, 1475, 1479, 
	1482, 1485, 1488, 1493, 1496, 1498, 1501, 1505, 
	1507, 1509, 1511, 1513, 1515, 1517, 1520, 1523, 
	1538, 1541, 1544, 1546, 1550, 1554, 1557, 1560, 
	1563, 1566, 1569, 1574, 1577, 1579, 1581, 1586, 
	1588, 1590, 1592, 1594, 1596, 1598, 1602, 1606, 
	1608, 1610, 1612, 1615, 1620, 1624, 1626, 1628, 
	1630, 1632, 1634, 1636, 1638, 1642, 1646, 1649, 
	1652, 1655, 1658, 1661, 1664, 1667, 1672, 1674, 
	1677, 1679, 1681, 1685, 1689, 1692, 1697, 1702, 
	1704, 1706, 1708, 1710, 1712, 1714, 1718, 1722, 
	1724, 1726, 1728, 1730, 1734, 1740, 1746, 1751, 
	1753, 1755, 1757, 1759, 1761, 1763, 1765, 1767, 
	1770, 1772, 1774, 1778, 1783, 1788, 1790, 1792, 
	1794, 1796, 1798, 1801, 1807, 1809, 1811, 1814, 
	1818, 1824, 1830, 1832, 1834, 1836, 1838, 1840, 
	1842, 1844, 1846, 1848, 1851, 1853, 1855, 1857, 
	1859, 1861, 1865, 1869, 1873, 1875, 1878, 1880, 
	1882, 1884, 1886, 1888, 1890, 1892, 1894, 1896, 
	1898, 1900, 1902, 1904, 1906, 1908, 1910, 1912, 
	1914, 1916, 1918, 1920, 1924, 1926, 1928, 1930, 
	1932, 1934, 1936, 1938, 1940, 1942, 1944, 1948, 
	1950, 1952, 1954, 1956, 1958, 1960, 1961, 1963, 
	1966, 1968, 1969, 1970, 1972, 1975, 1977
};

static const short _ascii_trans_targs[] = {
	5, 23, 29, 39, 61, 134, 147, 148, 
	192, 215, 246, 259, 283, 286, 304, 311, 
	314, 330, 336, 342, 345, 351, 363, 2, 
	0, 741, 3, 4, 2, 0, 741, 0, 
	741, 3, 4, 0, 6, 0, 7, 0, 
	8, 0, 9, 0, 10, 0, 11, 0, 
	12, 0, 13, 0, 14, 0, 15, 0, 
	16, 0, 18, 19, 17, 18, 17, 742, 
	18, 17, 18, 20, 17, 18, 21, 20, 
	17, 18, 22, 17, 18, 17, 24, 0, 
	25, 0, 26, 0, 27, 0, 28, 0, 
	743, 0, 30, 32, 35, 0, 31, 0, 
	741, 3, 0, 33, 0, 34, 0, 31, 
	0, 36, 0, 37, 0, 38, 0, 31, 
	0, 40, 0, 41, 0, 42, 0, 43, 
	0, 44, 0, 45, 0, 45, 0, 0, 
	46, 47, 0, 0, 46, 47, 48, 49, 
	0, 49, 0, 50, 49, 0, 50, 51, 
	0, 52, 51, 0, 52, 53, 0, 54, 
	58, 59, 53, 0, 55, 57, 0, 56, 
	0, 30, 0, 55, 0, 54, 0, 59, 
	60, 0, 54, 58, 60, 0, 62, 0, 
	63, 0, 64, 0, 65, 0, 65, 0, 
	0, 66, 67, 0, 0, 66, 67, 68, 
	0, 69, 0, 70, 0, 71, 0, 71, 
	127, 72, 0, 73, 72, 0, 73, 74, 
	0, 75, 0, 76, 0, 77, 0, 78, 
	0, 79, 0, 80, 0, 81, 0, 81, 
	82, 0, 83, 82, 0, 83, 84, 0, 
	85, 0, 86, 0, 87, 0, 88, 0, 
	88, 119, 120, 89, 119, 119, 0, 90, 
	119, 98, 89, 119, 119, 0, 91, 0, 
	92, 117, 0, 93, 0, 94, 115, 0, 
	95, 0, 98, 96, 0, 98, 97, 0, 
	98, 0, 98, 99, 0, 100, 0, 101, 
	0, 102, 0, 103, 0, 104, 0, 105, 
	0, 106, 0, 107, 0, 108, 0, 109, 
	0, 110, 0, 111, 0, 111, 112, 0, 
	55, 113, 114, 112, 0, 55, 0, 55, 
	113, 114, 0, 94, 116, 0, 94, 0, 
	92, 118, 0, 92, 0, 119, 98, 89, 
	119, 119, 0, 121, 0, 122, 0, 123, 
	0, 124, 0, 125, 0, 126, 0, 98, 
	0, 128, 0, 129, 0, 130, 0, 131, 
	0, 132, 0, 133, 0, 73, 0, 135, 
	0, 136, 0, 137, 0, 138, 142, 0, 
	139, 0, 140, 0, 141, 0, 743, 0, 
	143, 0, 144, 0, 145, 0, 146, 0, 
	31, 0, 31, 0, 149, 166, 0, 150, 
	0, 151, 0, 152, 0, 153, 0, 154, 
	0, 155, 0, 156, 0, 157, 0, 158, 
	0, 159, 0, 161, 162, 160, 161, 160, 
	744, 161, 160, 161, 163, 160, 161, 164, 
	163, 160, 161, 165, 160, 161, 160, 167, 
	189, 0, 168, 178, 0, 169, 0, 170, 
	0, 171, 0, 172, 0, 173, 0, 174, 
	0, 175, 0, 176, 0, 31, 177, 0, 
	31, 0, 179, 0, 0, 0, 180, 181, 
	0, 0, 180, 188, 0, 0, 182, 183, 
	187, 0, 0, 182, 56, 184, 0, 185, 
	0, 186, 0, 178, 0, 183, 0, 183, 
	187, 188, 0, 0, 182, 190, 0, 191, 
	0, 31, 0, 193, 207, 0, 194, 0, 
	195, 0, 196, 0, 197, 0, 197, 0, 
	0, 198, 199, 0, 0, 198, 199, 200, 
	0, 201, 200, 0, 201, 202, 0, 203, 
	204, 205, 202, 0, 55, 113, 0, 203, 
	0, 205, 206, 0, 203, 204, 206, 0, 
	208, 0, 209, 0, 210, 0, 211, 0, 
	212, 0, 213, 0, 741, 3, 214, 741, 
	3, 214, 216, 242, 0, 217, 236, 0, 
	218, 0, 218, 0, 0, 219, 220, 0, 
	0, 219, 220, 221, 0, 222, 221, 0, 
	222, 223, 0, 224, 223, 0, 224, 225, 
	0, 31, 226, 227, 225, 0, 31, 0, 
	31, 226, 227, 228, 0, 229, 0, 230, 
	0, 231, 0, 232, 0, 233, 0, 234, 
	0, 31, 226, 235, 0, 31, 226, 235, 
	0, 237, 0, 238, 0, 239, 0, 240, 
	241, 0, 741, 3, 240, 241, 0, 741, 
	3, 241, 0, 243, 0, 244, 0, 245, 
	0, 217, 0, 247, 0, 248, 0, 249, 
	0, 249, 0, 0, 250, 251, 0, 0, 
	250, 251, 252, 0, 253, 252, 0, 253, 
	254, 0, 255, 254, 0, 255, 256, 0, 
	257, 256, 0, 257, 258, 0, 31, 226, 
	235, 258, 0, 260, 0, 261, 275, 0, 
	262, 0, 263, 0, 263, 0, 0, 264, 
	265, 0, 0, 264, 265, 266, 0, 741, 
	3, 267, 266, 0, 741, 3, 267, 268, 
	0, 269, 0, 270, 0, 271, 0, 272, 
	0, 273, 0, 274, 0, 741, 3, 4, 
	0, 276, 0, 277, 0, 278, 0, 279, 
	0, 279, 0, 0, 280, 741, 3, 281, 
	0, 0, 280, 741, 3, 281, 268, 282, 
	0, 741, 3, 267, 282, 0, 284, 0, 
	285, 0, 238, 0, 287, 0, 288, 0, 
	289, 0, 290, 0, 291, 0, 292, 297, 
	0, 293, 0, 294, 0, 741, 3, 295, 
	0, 741, 3, 295, 296, 0, 741, 3, 
	4, 296, 0, 298, 0, 299, 0, 300, 
	0, 301, 0, 302, 0, 0, 0, 303, 
	741, 3, 4, 0, 0, 303, 305, 0, 
	306, 0, 307, 310, 0, 307, 0, 0, 
	308, 741, 3, 309, 0, 0, 308, 741, 
	3, 309, 0, 0, 308, 307, 0, 312, 
	0, 313, 0, 262, 0, 315, 0, 316, 
	0, 317, 0, 318, 0, 319, 0, 320, 
	322, 0, 321, 0, 310, 0, 323, 0, 
	324, 0, 325, 0, 325, 0, 0, 326, 
	327, 0, 0, 326, 327, 328, 329, 0, 
	329, 0, 220, 329, 0, 331, 0, 332, 
	0, 333, 0, 334, 0, 335, 0, 310, 
	0, 337, 0, 338, 0, 339, 0, 340, 
	0, 341, 0, 217, 0, 343, 0, 344, 
	0, 4, 0, 346, 0, 347, 0, 348, 
	0, 349, 0, 350, 0, 217, 0, 352, 
	353, 359, 0, 217, 0, 354, 0, 355, 
	0, 356, 0, 357, 0, 358, 0, 294, 
	0, 360, 0, 361, 0, 362, 0, 741, 
	3, 239, 0, 364, 0, 365, 0, 366, 
	0, 367, 0, 368, 0, 4, 0, 373, 
	391, 397, 407, 429, 502, 515, 516, 560, 
	370, 0, 746, 371, 372, 370, 0, 746, 
	0, 746, 371, 372, 0, 374, 0, 375, 
	0, 376, 0, 377, 0, 378, 0, 379, 
	0, 380, 0, 381, 0, 382, 0, 383, 
	0, 384, 0, 386, 387, 385, 386, 385, 
	747, 386, 385, 386, 388, 385, 386, 389, 
	388, 385, 386, 390, 385, 386, 385, 392, 
	0, 393, 0, 394, 0, 395, 0, 396, 
	0, 748, 0, 398, 400, 403, 0, 399, 
	0, 746, 371, 0, 401, 0, 402, 0, 
	399, 0, 404, 0, 405, 0, 406, 0, 
	399, 0, 408, 0, 409, 0, 410, 0, 
	411, 0, 412, 0, 413, 0, 413, 0, 
	0, 414, 415, 0, 0, 414, 415, 416, 
	417, 0, 417, 0, 418, 417, 0, 418, 
	419, 0, 420, 419, 0, 420, 421, 0, 
	422, 426, 427, 421, 0, 423, 425, 0, 
	424, 0, 398, 0, 423, 0, 422, 0, 
	427, 428, 0, 422, 426, 428, 0, 430, 
	0, 431, 0, 432, 0, 433, 0, 433, 
	0, 0, 434, 435, 0, 0, 434, 435, 
	436, 0, 437, 0, 438, 0, 439, 0, 
	439, 495, 440, 0, 441, 440, 0, 441, 
	442, 0, 443, 0, 444, 0, 445, 0, 
	446, 0, 447, 0, 448, 0, 449, 0, 
	449, 450, 0, 451, 450, 0, 451, 452, 
	0, 453, 0, 454, 0, 455, 0, 456, 
	0, 456, 487, 488, 457, 487, 487, 0, 
	458, 487, 466, 457, 487, 487, 0, 459, 
	0, 460, 485, 0, 461, 0, 462, 483, 
	0, 463, 0, 466, 464, 0, 466, 465, 
	0, 466, 0, 466, 467, 0, 468, 0, 
	469, 0, 470, 0, 471, 0, 472, 0, 
	473, 0, 474, 0, 475, 0, 476, 0, 
	477, 0, 478, 0, 479, 0, 479, 480, 
	0, 423, 481, 482, 480, 0, 423, 0, 
	423, 481, 482, 0, 462, 484, 0, 462, 
	0, 460, 486, 0, 460, 0, 487, 466, 
	457, 487, 487, 0, 489, 0, 490, 0, 
	491, 0, 492, 0, 493, 0, 494, 0, 
	466, 0, 496, 0, 497, 0, 498, 0, 
	499, 0, 500, 0, 501, 0, 441, 0, 
	503, 0, 504, 0, 505, 0, 506, 510, 
	0, 507, 0, 508, 0, 509, 0, 748, 
	0, 511, 0, 512, 0, 513, 0, 514, 
	0, 399, 0, 399, 0, 517, 534, 0, 
	518, 0, 519, 0, 520, 0, 521, 0, 
	522, 0, 523, 0, 524, 0, 525, 0, 
	526, 0, 527, 0, 529, 530, 528, 529, 
	528, 749, 529, 528, 529, 531, 528, 529, 
	532, 531, 528, 529, 533, 528, 529, 528, 
	535, 557, 0, 536, 546, 0, 537, 0, 
	538, 0, 539, 0, 540, 0, 541, 0, 
	542, 0, 543, 0, 544, 0, 399, 545, 
	0, 399, 0, 547, 0, 0, 0, 548, 
	549, 0, 0, 548, 556, 0, 0, 550, 
	551, 555, 0, 0, 550, 424, 552, 0, 
	553, 0, 554, 0, 546, 0, 551, 0, 
	551, 555, 556, 0, 0, 550, 558, 0, 
	559, 0, 399, 0, 561, 575, 0, 562, 
	0, 563, 0, 564, 0, 565, 0, 565, 
	0, 0, 566, 567, 0, 0, 566, 567, 
	568, 0, 569, 568, 0, 569, 570, 0, 
	571, 572, 573, 570, 0, 423, 481, 0, 
	571, 0, 573, 574, 0, 571, 572, 574, 
	0, 576, 0, 577, 0, 578, 0, 579, 
	0, 580, 0, 581, 0, 746, 371, 582, 
	746, 371, 582, 584, 617, 630, 655, 658, 
	676, 683, 686, 702, 708, 714, 717, 723, 
	735, 0, 585, 613, 0, 586, 607, 0, 
	587, 0, 587, 0, 0, 588, 589, 0, 
	0, 588, 589, 590, 0, 591, 590, 0, 
	591, 592, 0, 593, 592, 0, 593, 594, 
	0, 595, 597, 598, 594, 0, 750, 596, 
	0, 750, 0, 595, 0, 595, 597, 598, 
	599, 0, 600, 0, 601, 0, 602, 0, 
	603, 0, 604, 0, 605, 0, 595, 597, 
	606, 0, 595, 597, 606, 0, 608, 0, 
	609, 0, 610, 0, 611, 612, 0, 750, 
	596, 611, 612, 0, 750, 596, 612, 0, 
	614, 0, 615, 0, 616, 0, 586, 0, 
	618, 0, 619, 0, 620, 0, 620, 0, 
	0, 621, 622, 0, 0, 621, 622, 623, 
	0, 624, 623, 0, 624, 625, 0, 626, 
	625, 0, 626, 627, 0, 628, 627, 0, 
	628, 629, 0, 595, 597, 606, 629, 0, 
	631, 0, 632, 647, 0, 633, 0, 634, 
	0, 634, 0, 0, 635, 636, 0, 0, 
	635, 636, 637, 0, 750, 596, 638, 637, 
	0, 750, 596, 638, 639, 0, 640, 0, 
	641, 0, 642, 0, 643, 0, 644, 0, 
	645, 0, 750, 596, 646, 0, 750, 596, 
	646, 0, 648, 0, 649, 0, 650, 0, 
	651, 0, 651, 0, 0, 652, 750, 596, 
	653, 0, 0, 652, 750, 596, 653, 639, 
	654, 0, 750, 596, 638, 654, 0, 656, 
	0, 657, 0, 609, 0, 659, 0, 660, 
	0, 661, 0, 662, 0, 663, 0, 664, 
	669, 0, 665, 0, 666, 0, 750, 596, 
	667, 0, 750, 596, 667, 668, 0, 750, 
	596, 646, 668, 0, 670, 0, 671, 0, 
	672, 0, 673, 0, 674, 0, 0, 0, 
	675, 750, 596, 646, 0, 0, 675, 677, 
	0, 678, 0, 679, 682, 0, 679, 0, 
	0, 680, 750, 596, 681, 0, 0, 680, 
	750, 596, 681, 0, 0, 680, 679, 0, 
	684, 0, 685, 0, 633, 0, 687, 0, 
	688, 0, 689, 0, 690, 0, 691, 0, 
	692, 694, 0, 693, 0, 682, 0, 695, 
	0, 696, 0, 697, 0, 697, 0, 0, 
	698, 699, 0, 0, 698, 699, 700, 701, 
	0, 701, 0, 589, 701, 0, 703, 0, 
	704, 0, 705, 0, 706, 0, 707, 0, 
	682, 0, 709, 0, 710, 0, 711, 0, 
	712, 0, 713, 0, 586, 0, 715, 0, 
	716, 0, 646, 0, 718, 0, 719, 0, 
	720, 0, 721, 0, 722, 0, 586, 0, 
	724, 725, 731, 0, 586, 0, 726, 0, 
	727, 0, 728, 0, 729, 0, 730, 0, 
	666, 0, 732, 0, 733, 0, 734, 0, 
	750, 596, 610, 0, 736, 0, 737, 0, 
	738, 0, 739, 0, 740, 0, 646, 0, 
	0, 18, 17, 741, 3, 0, 161, 160, 
	0, 0, 386, 385, 746, 371, 0, 529, 
	528, 0, 0
};

static const unsigned char _ascii_trans_actions[] = {
	0, 0, 144, 0, 37, 0, 0, 0, 
	31, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	0, 162, 90, 90, 0, 0, 3, 0, 
	3, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 1, 1, 0, 0, 213, 
	0, 0, 1, 1, 1, 0, 7, 0, 
	0, 1, 1, 1, 1, 1, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	21, 0, 0, 0, 0, 0, 0, 0, 
	3, 0, 0, 0, 0, 0, 0, 9, 
	0, 0, 0, 0, 0, 0, 0, 17, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	132, 87, 0, 0, 0, 0, 1, 1, 
	0, 0, 0, 96, 0, 0, 0, 1, 
	0, 102, 0, 0, 0, 1, 0, 186, 
	114, 114, 0, 0, 33, 0, 0, 0, 
	0, 0, 0, 33, 0, 27, 0, 0, 
	1, 0, 190, 117, 0, 0, 0, 0, 
	0, 0, 0, 0, 35, 0, 0, 0, 
	0, 132, 87, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 111, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	1, 0, 105, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 1, 1, 1, 0, 0, 
	0, 120, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 120, 0, 0, 120, 0, 0, 
	120, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 1, 0, 
	102, 102, 102, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 120, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 25, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 19, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	15, 0, 41, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 1, 0, 0, 
	208, 0, 0, 1, 1, 1, 0, 7, 
	0, 0, 1, 1, 1, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 13, 0, 3, 0, 0, 
	3, 0, 39, 0, 0, 0, 1, 123, 
	0, 0, 0, 1, 0, 0, 1, 126, 
	126, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 126, 
	126, 1, 0, 0, 1, 0, 0, 0, 
	0, 11, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 29, 0, 0, 0, 
	0, 132, 87, 0, 0, 0, 0, 1, 
	0, 102, 0, 0, 0, 1, 0, 186, 
	114, 114, 0, 0, 0, 0, 0, 27, 
	0, 0, 1, 0, 190, 117, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 198, 150, 1, 194, 
	129, 0, 0, 0, 0, 45, 0, 0, 
	0, 0, 0, 0, 0, 135, 87, 0, 
	0, 0, 0, 1, 0, 102, 0, 0, 
	0, 1, 0, 105, 0, 0, 0, 1, 
	0, 186, 114, 114, 0, 0, 27, 0, 
	27, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 141, 23, 23, 0, 27, 0, 0, 
	0, 0, 0, 75, 0, 0, 0, 1, 
	1, 0, 166, 93, 1, 1, 0, 166, 
	93, 0, 0, 0, 0, 0, 0, 0, 
	0, 51, 0, 0, 0, 0, 0, 83, 
	0, 0, 0, 0, 135, 87, 0, 0, 
	0, 0, 1, 0, 102, 0, 0, 0, 
	1, 0, 105, 0, 0, 0, 1, 0, 
	114, 0, 0, 0, 1, 0, 170, 99, 
	99, 0, 0, 0, 0, 0, 0, 0, 
	67, 0, 0, 0, 0, 0, 0, 135, 
	87, 0, 0, 0, 0, 1, 0, 178, 
	108, 108, 0, 0, 3, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 138, 23, 23, 
	0, 0, 0, 0, 0, 55, 0, 0, 
	0, 0, 0, 0, 135, 154, 87, 87, 
	0, 0, 0, 3, 0, 0, 0, 1, 
	0, 174, 105, 105, 0, 0, 0, 0, 
	0, 0, 75, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 79, 0, 3, 0, 0, 
	0, 3, 0, 0, 1, 0, 182, 111, 
	111, 0, 0, 0, 0, 0, 0, 0, 
	0, 81, 0, 0, 0, 0, 0, 135, 
	154, 87, 87, 0, 0, 0, 0, 0, 
	57, 0, 0, 59, 0, 0, 0, 0, 
	135, 218, 203, 158, 0, 0, 0, 147, 
	85, 0, 0, 0, 135, 0, 0, 0, 
	0, 0, 0, 65, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 61, 0, 0, 0, 
	49, 0, 0, 0, 0, 0, 0, 135, 
	87, 0, 0, 0, 0, 1, 1, 0, 
	0, 0, 96, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 63, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 53, 0, 0, 0, 0, 
	0, 71, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 47, 0, 0, 
	0, 0, 0, 43, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 77, 
	0, 0, 0, 0, 0, 73, 0, 3, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 69, 0, 0, 
	0, 144, 0, 37, 0, 0, 0, 31, 
	1, 0, 162, 90, 90, 0, 0, 3, 
	0, 3, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 1, 1, 1, 0, 0, 
	213, 0, 0, 1, 1, 1, 0, 7, 
	0, 0, 1, 1, 1, 1, 1, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 21, 0, 0, 0, 0, 0, 0, 
	0, 3, 0, 0, 0, 0, 0, 0, 
	9, 0, 0, 0, 0, 0, 0, 0, 
	17, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 132, 87, 0, 0, 0, 0, 1, 
	1, 0, 0, 0, 96, 0, 0, 0, 
	1, 0, 102, 0, 0, 0, 1, 0, 
	186, 114, 114, 0, 0, 33, 0, 0, 
	0, 0, 0, 0, 33, 0, 27, 0, 
	0, 1, 0, 190, 117, 0, 0, 0, 
	0, 0, 0, 0, 0, 35, 0, 0, 
	0, 0, 132, 87, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 0, 111, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 1, 0, 105, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 1, 0, 1, 1, 1, 0, 
	0, 0, 120, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 120, 0, 0, 120, 0, 
	0, 120, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 1, 
	0, 102, 102, 102, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 120, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 25, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 19, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 15, 0, 41, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 1, 1, 1, 0, 
	0, 208, 0, 0, 1, 1, 1, 0, 
	7, 0, 0, 1, 1, 1, 1, 1, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 13, 0, 3, 0, 
	0, 3, 0, 39, 0, 0, 0, 1, 
	123, 0, 0, 0, 1, 0, 0, 1, 
	126, 126, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	126, 126, 1, 0, 0, 1, 0, 0, 
	0, 0, 11, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 29, 0, 0, 
	0, 0, 132, 87, 0, 0, 0, 0, 
	1, 0, 102, 0, 0, 0, 1, 0, 
	186, 114, 114, 0, 0, 0, 0, 0, 
	27, 0, 0, 1, 0, 190, 117, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 198, 150, 1, 
	194, 129, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 45, 0, 0, 
	0, 0, 0, 0, 0, 135, 87, 0, 
	0, 0, 0, 1, 0, 102, 0, 0, 
	0, 1, 0, 105, 0, 0, 0, 1, 
	0, 186, 114, 114, 0, 0, 3, 0, 
	0, 3, 0, 27, 0, 27, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 141, 23, 
	23, 0, 27, 0, 0, 0, 0, 0, 
	75, 0, 0, 0, 1, 1, 0, 166, 
	93, 1, 1, 0, 166, 93, 0, 0, 
	0, 0, 0, 0, 0, 0, 51, 0, 
	0, 0, 0, 0, 83, 0, 0, 0, 
	0, 135, 87, 0, 0, 0, 0, 1, 
	0, 102, 0, 0, 0, 1, 0, 105, 
	0, 0, 0, 1, 0, 114, 0, 0, 
	0, 1, 0, 170, 99, 99, 0, 0, 
	0, 0, 0, 0, 0, 67, 0, 0, 
	0, 0, 0, 0, 135, 87, 0, 0, 
	0, 0, 1, 0, 178, 108, 108, 0, 
	0, 3, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 138, 23, 23, 0, 3, 0, 
	0, 0, 0, 0, 0, 0, 55, 0, 
	0, 0, 0, 0, 0, 135, 154, 87, 
	87, 0, 0, 0, 3, 0, 0, 0, 
	1, 0, 174, 105, 105, 0, 0, 0, 
	0, 0, 0, 75, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 79, 0, 3, 0, 
	0, 0, 3, 0, 0, 1, 0, 182, 
	111, 111, 0, 0, 0, 0, 0, 0, 
	0, 0, 81, 0, 0, 0, 0, 0, 
	135, 154, 87, 87, 0, 0, 0, 0, 
	0, 57, 0, 0, 59, 0, 0, 0, 
	0, 135, 218, 203, 158, 0, 0, 0, 
	147, 85, 0, 0, 0, 135, 0, 0, 
	0, 0, 0, 0, 65, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 61, 0, 0, 
	0, 49, 0, 0, 0, 0, 0, 0, 
	135, 87, 0, 0, 0, 0, 1, 1, 
	0, 0, 0, 96, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	63, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 53, 0, 0, 0, 
	0, 0, 71, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 47, 0, 
	0, 0, 0, 0, 43, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	77, 0, 0, 0, 0, 0, 73, 0, 
	3, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 69, 0, 
	0, 0, 0, 3, 0, 0, 0, 0, 
	0, 0, 0, 0, 3, 0, 0, 0, 
	0, 0, 0
};

static const unsigned char _ascii_eof_actions[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 0, 0, 0, 0, 0, 0, 0, 
	0, 5, 0, 0, 0, 0, 0
};

static const int ascii_start = 1;
static const int ascii_first_final = 741;
static const int ascii_error = 0;

static const int ascii_en_error_handling = 745;
static const int ascii_en_reply = 369;
static const int ascii_en_request = 583;
static const int ascii_en_request_reply = 1;


#line 493 "mcrouter/lib/mc/ascii_client.rl"


int get_reply_ragel_start_state() {
  return ascii_en_reply;
}

int get_request_ragel_start_state() {
  return ascii_en_request;
}

int get_request_reply_ragel_start_state() {
  return ascii_en_request_reply;
}

/** ascii reply parsing
    This is the real workhorse. It consumes buf, resuming the partial reply if
    one exists. As each reply is fully received, we call mcc_req_complete().
    If there is a parse error or remote error, we handle that as well. If
    there is a parse error or unrecoverable remote error, we call
    mcc_on_down() and the rest of the buffer is ignored.
    @return 0 on error */
int _on_ascii_rx(mc_parser_t* parser, char* buf, size_t nbuf) {
  FBI_ASSERT(parser);
  FBI_ASSERT(buf);
  dbg_fentry("parser=%p nbuf=%lu", parser, nbuf);

  int success = 0;
  bool isError = false;

  // ragel variables
  int cs = ascii_error; // current state
  char* p = buf;
  char* pe = buf + nbuf;
  char* eof = NULL;
  
#line 1273 "mcrouter/lib/mc/ascii_client.c"
	{
	}

#line 528 "mcrouter/lib/mc/ascii_client.rl"

  char* ts = NULL; // token start
  size_t tlen = 0; // token length

  int nmsgs = 0;

  /* each iteration of this loop processes one msg, or in the case of value
     msgs the header of the msg, the body of the msg, or the tail of
     the msg. If we reach the end of buf before the end of a msg (whether
     in data or header/tail), we have a partial read and will resume when the
     next packet arrives. */
  while (p < pe) {
    /* sanity check: if memcached has a bug, or we somehow lost a msg, log
       the whatever's left and disconnect */
    if (parser->parser_state == parser_idle) {
      dbg_error("Unexpected msg '%s'", p);
      parser->parse_error(parser->context, parser->error);
      break;
    }

    FBI_ASSERT(parser->parser_state == parser_msg_header ||
           parser->parser_state == parser_body ||
           parser->parser_state == parser_partial);

    /* prepare to resume. If we're not in the middle of a msg, these will
       not be used */
    cs = parser->ragel_state;

    if (parser->parser_state == parser_msg_header) {
      if (parser->msg != NULL) {
        dbg_error("parser->msg already exists at start of new message. "
                  "Probable memory leak.");
      }

      // new msg
      parser->msg = mc_msg_new(0);
      if (parser->msg == NULL) {
        parser->error = parser_out_of_memory;
        parser->resid = parser->off = 0;
        parser->parse_error(parser->context, parser->error);
        success = 0;
        goto epilogue;
      }

      cs = parser->ragel_start_state;
      parser->parser_state = parser_partial;
    }
    FBI_ASSERT(parser->msg);

    dbg_low("resid=%lu msg=%p parser_state=%s cs=%d",
            pe - p, parser->msg,
            parser_state_to_string(parser->parser_state), cs);

    if (parser->parser_state == parser_body) {
      FBI_ASSERT(pe >= p);
      size_t n = MIN(parser->resid, (size_t)(pe - p));
      memcpy(&parser->msg->value.str[parser->off], p, n);
      p += n;
      parser->off += n;
      FBI_ASSERT(parser->resid >= n);
      parser->resid -= n;
      if (parser->resid == 0) {
        FBI_ASSERT(parser->off == parser->msg->value.len);
        parser->parser_state = parser_partial;
      }
    } else {
      if (parser->partial_token) {
        // we're in the middle of a token
        ts = p;
      } else {
        ts = NULL;
      }

      /* this is where ragel emits the state machine code */
      
#line 1353 "mcrouter/lib/mc/ascii_client.c"
	{
	int _klen;
	unsigned int _trans;
	const char *_acts;
	unsigned int _nacts;
	const char *_keys;

	if ( p == pe )
		goto _test_eof;
	if ( cs == 0 )
		goto _out;
_resume:
	_keys = _ascii_trans_keys + _ascii_key_offsets[cs];
	_trans = _ascii_index_offsets[cs];

	_klen = _ascii_single_lengths[cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + _klen - 1;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + ((_upper-_lower) >> 1);
			if ( (*p) < *_mid )
				_upper = _mid - 1;
			else if ( (*p) > *_mid )
				_lower = _mid + 1;
			else {
				_trans += (unsigned int)(_mid - _keys);
				goto _match;
			}
		}
		_keys += _klen;
		_trans += _klen;
	}

	_klen = _ascii_range_lengths[cs];
	if ( _klen > 0 ) {
		const char *_lower = _keys;
		const char *_mid;
		const char *_upper = _keys + (_klen<<1) - 2;
		while (1) {
			if ( _upper < _lower )
				break;

			_mid = _lower + (((_upper-_lower) >> 1) & ~1);
			if ( (*p) < _mid[0] )
				_upper = _mid - 2;
			else if ( (*p) > _mid[1] )
				_lower = _mid + 2;
			else {
				_trans += (unsigned int)((_mid - _keys)>>1);
				goto _match;
			}
		}
		_trans += _klen;
	}

_match:
	cs = _ascii_trans_targs[_trans];

	if ( _ascii_trans_actions[_trans] == 0 )
		goto _again;

	_acts = _ascii_actions + _ascii_trans_actions[_trans];
	_nacts = (unsigned int) *_acts++;
	while ( _nacts-- > 0 )
	{
		switch ( *_acts++ )
		{
	case 0:
#line 31 "mcrouter/lib/mc/ascii_client.rl"
	{
  if (!skipping_key(parser)) {
    parser->partial_token = 1;
    parser->te = parser->tbuf;
    ts = p;
  }
}
	break;
	case 1:
#line 38 "mcrouter/lib/mc/ascii_client.rl"
	{
  if (parser->partial_token && !skipping_key(parser)) {
    FBI_ASSERT(ts);
    parser->partial_token = 0;
    if (parser->te && parser->te > parser->tbuf) {
      /* we have something stuffed in our cheeks,
         let's put them together and update ts. */
      FBI_ASSERT(ts <= p);
      size_t n = p - ts;
      if(mc_parser_ensure_tbuf(parser, n) != 0) {
        if (parser->in_key) {
          parser->bad_key = 1;
        } else {
          parser->error = parser_malformed_request;
          {cs = 745; goto _again;}
        }
      } else {
        strncpy(parser->te, ts, n);
        parser->te += n;
        *parser->te = '\0';
        tlen = parser->te - parser->tbuf;
        ts = parser->tbuf;
      }
    } else {
      tlen = p - ts;
      if (tlen >= MC_TOKEN_MAX_LEN) {
        if (parser->in_key) {
          parser->bad_key = 1;
        } else {
          parser->error = parser_malformed_request;
          {cs = 745; goto _again;}
        }
      }
    }
  }
}
	break;
	case 2:
#line 75 "mcrouter/lib/mc/ascii_client.rl"
	{
  if (!skipping_key(parser)) {
    if (tlen > MC_KEY_MAX_LEN_ASCII) {
      parser->bad_key = 1;
    }
    if (parser->bad_key) {
      parser->msg->result = mc_res_bad_key;
    } else {
      if (mc_msg_grow(&parser->msg, tlen + 1,
                      (void**) &parser->msg->key.str) != 0) {
        parser->error = parser_out_of_memory;
        {cs = 745; goto _again;}
      }
      parser->msg->key.len = tlen;
      strncpy(parser->msg->key.str, ts, tlen);
      FBI_ASSERT(!memcmp(parser->msg->key.str, ts, tlen));
      parser->msg->key.str[tlen] = '\0';
    }
  }
  parser->in_skipped_key = 0;
  parser->in_key = 0;
  parser->bad_key = 0;
}
	break;
	case 3:
#line 99 "mcrouter/lib/mc/ascii_client.rl"
	{
  FBI_ASSERT(parser->msg != NULL);

  // end of msg, fake eof
  pe = eof = p + 1;
  parser->parser_state = parser_msg_header;
  /* Note: we need to reset parser->msg first,
     in case mc_parser_reset is called from the callback */
  mc_msg_t* msg = parser->msg;
  parser->msg = NULL;
  parser->msg_ready(parser->context, 0, msg);
  nmsgs++;

  mc_parser_cleanup_tbuf(parser);
}
	break;
	case 5:
#line 133 "mcrouter/lib/mc/ascii_client.rl"
	{
    parser->msg->err_code = strtoll(ts, NULL, 10);
  }
	break;
	case 6:
#line 137 "mcrouter/lib/mc/ascii_client.rl"
	{
  // Since the token we are parsing includes the \r\n, we need
  // to invoke this code upon entering the DFA's final state.
  // Only the '\r' is stored in the token buffer, so we only
  // need to remove one character.
  tlen--;
  if (mc_msg_grow(&parser->msg, tlen + 1,
                  (void**) &parser->msg->value.str) != 0) {
    parser->error = parser_out_of_memory;
    {cs = 745; goto _again;}
  }
  parser->msg->value.len = tlen;
  memcpy(parser->msg->value.str, ts, tlen);
  parser->msg->value.str[tlen] = '\0';
}
	break;
	case 7:
#line 166 "mcrouter/lib/mc/ascii_client.rl"
	{
    if (parser->msg->err_code == SERVER_ERROR_BUSY) {
      parser->msg->result = mc_res_busy;
    } else {
      parser->msg->result = mc_res_remote_error;
    }
  }
	break;
	case 8:
#line 180 "mcrouter/lib/mc/ascii_client.rl"
	{
    parser->msg->result = mc_res_client_error;
  }
	break;
	case 9:
#line 186 "mcrouter/lib/mc/ascii_client.rl"
	{
    parser->msg->result = mc_res_local_error;
    parser->msg->value.str = "unexpected ERROR reply";
    parser->msg->value.len = strlen(parser->msg->value.str);
    dbg_error("%s", parser->msg->value.str);
    isError = true;
  }
	break;
	case 10:
#line 197 "mcrouter/lib/mc/ascii_client.rl"
	{
  FBI_ASSERT(parser->msg != NULL);

  mc_op_t op = parser->msg->op;
  /* Note: we need to reset parser->msg first,
     in case mc_parser_reset is called from the callback */
  mc_msg_t* msg = parser->msg;
  parser->msg = mc_msg_new(0);
  parser->msg_ready(parser->context, 0, msg);
  if (parser->msg == NULL) {
    parser->error = parser_out_of_memory;
    {cs = 745; goto _again;}
  }

  parser->msg->op = op;
}
	break;
	case 11:
#line 215 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_stored; }
	break;
	case 12:
#line 216 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->result = mc_res_stalestored;
}
	break;
	case 13:
#line 219 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_notstored; }
	break;
	case 14:
#line 220 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_exists; }
	break;
	case 15:
#line 221 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_notfound; }
	break;
	case 16:
#line 222 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_deleted; }
	break;
	case 17:
#line 227 "mcrouter/lib/mc/ascii_client.rl"
	{
    parser->msg->delta = strtoll(ts, NULL, 10);
    parser->msg->result = mc_res_stored;
  }
	break;
	case 18:
#line 233 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->in_skipped_key = 1; parser->in_key = 1; }
	break;
	case 19:
#line 238 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->in_skipped_key = 0; parser->in_key = 1; }
	break;
	case 20:
#line 244 "mcrouter/lib/mc/ascii_client.rl"
	{
  while (tlen > 0 && isspace(ts[tlen-1])) {
    tlen--;
  }
  if (mc_msg_grow(&parser->msg, tlen+1, (void**) &parser->msg->key.str) != 0) {
    parser->error = parser_out_of_memory;
    {cs = 745; goto _again;}
  }
  parser->msg->key.len = tlen;
  strncpy(parser->msg->key.str, ts, tlen);
  parser->msg->key.str[tlen] = '\0';
}
	break;
	case 21:
#line 257 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->lease_id = strtol(ts, NULL, 10);
}
	break;
	case 22:
#line 260 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->cas = strtoll(ts, NULL, 10);
}
	break;
	case 23:
#line 263 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->flags = strtoll(ts, NULL, 10);
}
	break;
	case 24:
#line 266 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->exptime = strtol(ts, NULL, 10);
}
	break;
	case 25:
#line 269 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->delta = strtoll(ts, NULL, 10);
}
	break;
	case 26:
#line 272 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->number = strtoll(ts, NULL, 10);
}
	break;
	case 27:
#line 275 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->noreply = true;
}
	break;
	case 28:
#line 279 "mcrouter/lib/mc/ascii_client.rl"
	{
  /* prepare for receiving data */
  size_t len = parser->resid = strtol(ts, NULL, 10);
  parser->off = 0;

  if (mc_msg_grow(&parser->msg, len + 1,
                  (void**) &parser->msg->value.str) != 0) {
    parser->error = parser_out_of_memory;
    {cs = 745; goto _again;}
  }
  parser->msg->value.str[len] = '\0';
  parser->msg->value.len = len;
}
	break;
	case 29:
#line 292 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->cas = strtoull(ts, NULL, 10);
}
	break;
	case 30:
#line 298 "mcrouter/lib/mc/ascii_client.rl"
	{
  ts[tlen]='\0';
  parser->msg->ipv = 0;
  if (strchr(ts, ':') == NULL) {
    if (inet_pton(AF_INET, ts, &parser->msg->ip_addr) > 0)
      parser->msg->ipv = 4;
  } else {
    if (inet_pton(AF_INET6, ts, &parser->msg->ip_addr) > 0)
      parser->msg->ipv = 6;
  }
}
	break;
	case 31:
#line 309 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->number = -1;}
	break;
	case 32:
#line 310 "mcrouter/lib/mc/ascii_client.rl"
	{
  /* the binary data of a specified isn't really regular, so we drop out of
     the state machine and read it, then come back in to finish the
     "\r\nEND\r\n". */
  parser->parser_state = parser_body;
  {p++; goto _out; }
}
	break;
	case 33:
#line 320 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_found; }
	break;
	case 34:
#line 325 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_notfound; }
	break;
	case 35:
#line 329 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_notfound; }
	break;
	case 36:
#line 331 "mcrouter/lib/mc/ascii_client.rl"
	{parser->msg->result = mc_res_found;}
	break;
	case 37:
#line 335 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_notfound; }
	break;
	case 38:
#line 346 "mcrouter/lib/mc/ascii_client.rl"
	{
  if (parser->msg->stats == NULL) {
    FBI_ASSERT(parser->msg->number == 0);
    size_t stats_size = sizeof(nstring_t) * 2 * MAX_NUM_STATS;
    if (mc_msg_grow(&parser->msg, stats_size, (void**) &parser->msg->stats)) {
      parser->error = parser_out_of_memory;
      {cs = 745; goto _again;}
    }
    memset(parser->msg->stats, 0, stats_size);
  }

  if (parser->msg->number < MAX_NUM_STATS) {
    parser->msg->number++;

    int idx = (parser->msg->number * 2) - 2;
    if (mc_msg_grow(&parser->msg, tlen + 1,
                    (void**) &parser->msg->stats[idx].str) != 0) {
      parser->error = parser_out_of_memory;
      {cs = 745; goto _again;}
    }
    parser->msg->stats[idx].len = tlen;
    parser->msg->stats[idx].str[tlen] = '\0';
    strncpy(parser->msg->stats[idx].str, ts, tlen);
  }
}
	break;
	case 39:
#line 373 "mcrouter/lib/mc/ascii_client.rl"
	{
  if (parser->msg->number <= MAX_NUM_STATS) {
    int idx = (parser->msg->number * 2) - 1;
    if (mc_msg_grow(&parser->msg, tlen + 1,
                    (void**) &parser->msg->stats[idx].str) != 0) {
      parser->error = parser_out_of_memory;
      {cs = 745; goto _again;}
    }

    parser->msg->stats[idx].len = tlen;
    parser->msg->stats[idx].str[tlen] = '\0';
    strncpy(parser->msg->stats[idx].str, ts, tlen);
  }
}
	break;
	case 40:
#line 388 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_ok; }
	break;
	case 41:
#line 390 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->result = mc_res_ok; }
	break;
	case 42:
#line 392 "mcrouter/lib/mc/ascii_client.rl"
	{
    // use new_msg because msg stays live if realloc fails and can leak
    mc_msg_t *new_msg = mc_msg_realloc(parser->msg,
                                       parser->msg->_extra_size + tlen + 1);
    if (new_msg == NULL) {
      parser->error = parser_out_of_memory;
      {cs = 745; goto _again;}
    }
    parser->msg = new_msg;
    parser->msg->result = mc_res_ok;
    char* version = parser->msg->value.str = (char *) &parser->msg[1];
    parser->msg->value.len = tlen;
    strncpy(version, ts, tlen);
    version[tlen] = '\0';
  }
	break;
	case 43:
#line 417 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_set; }
	break;
	case 44:
#line 418 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_add; }
	break;
	case 45:
#line 419 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_replace; }
	break;
	case 46:
#line 420 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_lease_set; }
	break;
	case 47:
#line 421 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_append; }
	break;
	case 48:
#line 422 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_prepend; }
	break;
	case 49:
#line 426 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_delete; }
	break;
	case 50:
#line 428 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_get; }
	break;
	case 51:
#line 429 "mcrouter/lib/mc/ascii_client.rl"
	{parser->msg->op = mc_op_gets; }
	break;
	case 52:
#line 430 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_lease_get; }
	break;
	case 53:
#line 431 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_metaget; }
	break;
	case 54:
#line 433 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_incr; }
	break;
	case 55:
#line 434 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_decr; }
	break;
	case 56:
#line 436 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_version; }
	break;
	case 57:
#line 438 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_quit;
                     parser->msg->noreply = true; }
	break;
	case 58:
#line 441 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_stats; }
	break;
	case 59:
#line 443 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_exec; }
	break;
	case 60:
#line 445 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_shutdown; }
	break;
	case 61:
#line 447 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_flushall; }
	break;
	case 62:
#line 448 "mcrouter/lib/mc/ascii_client.rl"
	{ parser->msg->op = mc_op_flushre; }
	break;
	case 63:
#line 450 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->op = mc_op_cas;
}
	break;
	case 64:
#line 458 "mcrouter/lib/mc/ascii_client.rl"
	{
  parser->msg->op = mc_op_end;
}
	break;
#line 1920 "mcrouter/lib/mc/ascii_client.c"
		}
	}

_again:
	if ( cs == 0 )
		goto _out;
	if ( ++p != pe )
		goto _resume;
	_test_eof: {}
	if ( p == eof )
	{
	const char *__acts = _ascii_actions + _ascii_eof_actions[cs];
	unsigned int __nacts = (unsigned int) *__acts++;
	while ( __nacts-- > 0 ) {
		switch ( *__acts++ ) {
	case 4:
#line 121 "mcrouter/lib/mc/ascii_client.rl"
	{
  if (parser->msg != NULL) {
    mc_msg_decref(parser->msg);
  }
  parser->msg = NULL;
  parser->te = NULL;
  parser->in_key = 0;
  parser->bad_key = 0;
  {p++; goto _out; }
}
	break;
#line 1949 "mcrouter/lib/mc/ascii_client.c"
		}
	}
	}

	_out: {}
	}

#line 603 "mcrouter/lib/mc/ascii_client.rl"

      // If we encountered 'ERROR' reply, fail all further data.
      if (isError) {
        goto epilogue;
      }

      /* if msg == NULL, we finished the msg */
      if (parser->msg) {
        parser->ragel_state = cs;
      } else {
        /* sentinel values */
        parser->ragel_state = ascii_error;
      }

      if (ts && parser->partial_token) {
        // we're in the middle of a token, stuff it in our cheeks
        int n = p - ts;
        if(mc_parser_ensure_tbuf(parser, n) == 0) {
          strncpy(parser->te, ts, n);
          parser->te += n;
        } else {
          if (parser->in_key) {
            parser->bad_key = 1;
          } else {
            // fake fgoto error here
            parser->error = parser_malformed_request;
            cs = ascii_error;
          }
        }
      }

      if (cs == ascii_error) {
        if (parser->msg != NULL) {
          mc_msg_decref(parser->msg);
          parser->msg = NULL;
        }
        parser->resid = parser->off = 0;
        parser->parse_error(parser->context, parser->error);
        goto epilogue;
      }
    }

    /* We may have adjusted pe and eof to simulate EOF at the end of a msg.
       Restore them for continued parsing of additional msgs. */
    pe = buf + nbuf;
    eof = NULL;
  }

  success = 1;

epilogue:
  dbg_fexit("%d msgs finished. parser_state=%s cs=%d",
            nmsgs, parser_state_to_string(parser->parser_state), cs);
  return success;
}


#line 661 "mcrouter/lib/mc/ascii_client.rl"


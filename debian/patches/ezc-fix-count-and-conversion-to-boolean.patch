Description: EZC: Fix count() and conversion to boolean of ProxyArray
 Fix JIT versions of count() and conversion of array to boolean, so
 that they work with ProxyArray. In both cases, duplicate the logic in
 ArrayData::size() -- if the sign bit of the size field is unset, use
 that field, otherwise call vsize().
Author: Tim Starling <tstarling@wikimedia.org>
Origin: backport, https://reviews.facebook.net/D23781
Reviewed-by: Giuseppe Lavagetto <glavagetto@wikimedia.org>

Index: hhvm/hphp/runtime/base/array-data.h
--- hhvm.orig/hphp/runtime/base/array-data.h
+++ hhvm/hphp/runtime/base/array-data.h
@@ -123,7 +123,7 @@ struct ArrayData {
 
   // unlike ArrayData::size(), this functions doesn't delegate
   // to the vsize() function, so its more efficient to use this when
-  // you know you don't have a NameValueTableWrapper.
+  // you know you don't have a NameValueTableWrapper or ProxyArray
   size_t getSize() const {
     return m_size;
   }
Index: hhvm/hphp/runtime/base/tv-helpers.cpp
===================================================================
--- hhvm.orig/hphp/runtime/base/tv-helpers.cpp
+++ hhvm/hphp/runtime/base/tv-helpers.cpp
@@ -111,9 +111,7 @@ void tvCastToBooleanInPlace(TypedValue* tv) {
   case KindOfDouble:  b = (tv->m_data.dbl != 0); break;
   case KindOfStaticString: b = tv->m_data.pstr->toBoolean(); break;
   case KindOfString:  b = tv->m_data.pstr->toBoolean(); tvDecRefStr(tv); break;
-  // Note that this is intentionally incorrect for NameValueTableWrapper, for
-  // which getSize() will always return -1, empty or not.
-  case KindOfArray:   b = !!tv->m_data.parr->getSize();
+  case KindOfArray:   b = !!tv->m_data.parr->size();
                       tvDecRefArr(tv);
                       break;
   case KindOfObject:  b = tv->m_data.pobj->o_toBoolean();

Index: hhvm/hphp/runtime/vm/jit/code-gen-x64.cpp
===================================================================
--- hhvm.orig/hphp/runtime/vm/jit/code-gen-x64.cpp
+++ hhvm/hphp/runtime/vm/jit/code-gen-x64.cpp
@@ -172,6 +172,26 @@ void CodeGenerator::unlikelyIfThenElse(Vout& v, Vout& vcold, ConditionCode cc,
   v = done;
 }
 
+// emit an if-then-else condition where the true case is unlikely.
+template <class T, class F>
+Vreg unlikelyCond(Vout& v, Vout& vc, ConditionCode cc, Vreg d, T t, F f) {
+    auto fblock = v.makeBlock();
+    auto tblock = vc.makeBlock();
+    auto done = v.makeBlock();
+    v << jcc{cc, {fblock, tblock}};
+    vc = tblock;
+    auto treg = t(vc);
+    vc << phijmp{done, vc.makeTuple(VregList{treg})};
+    v = fblock;
+    auto freg = f(v);
+    v << phijmp{done, v.makeTuple(VregList{freg})};
+    v = done;
+    v << phidef{v.makeTuple(VregList{d})};
+    return d;
+}
+
+
+
 /*
  * Generate an if-block that branches around some unlikely code, handling
  * the cases when a == astubs and a != astubs.  cc is the branch condition
@@ -2317,11 +2337,27 @@ void CodeGenerator::cgConvArrToBool(IRInstruction* inst) {
   auto srcReg = srcLoc(0).reg();
   auto& v = vmain();
 
-  // This will incorrectly result in "true" for a NameValueTableWrapper that is
-  // empty. You can only get such a thing through very contrived PHP, so the
-  // savings of a branch and a block of cold code outweights the edge-case bug.
-  v << cmplim{0, srcReg[ArrayData::offsetofSize()]};
-  v << setcc{CC_NZ, dstReg};
+  auto size = v.makeReg();
+  v << loadl{srcReg[ArrayData::offsetofSize()], size};
+  v << testl{size, size};
+
+  unlikelyCond(v, vcold(), CC_S, dstReg,
+    [&](Vout& v) {
+      auto vsize = v.makeReg();
+      auto dst1 = v.makeReg();
+      cgCallHelper(v, CppCall::method(&ArrayData::vsize),
+                   callDest(vsize), SyncOptions::kNoSyncPoint,
+                   argGroup().ssa(0));
+      v << testl{vsize, vsize};
+      v << setcc{CC_NZ, dst1};
+      return dst1;
+    },
+    [&](Vout& v) {
+      auto dst2 = v.makeReg();
+      v << setcc{CC_NZ, dst2};
+      return dst2;
+    }
+  );
 }
 
 /*
@@ -6203,14 +6239,21 @@ void CodeGenerator::cgCountArray(IRInstruction* inst) {
   auto const baseReg = srcLoc(0).reg();
   auto const dstReg  = dstLoc(0).reg();
   auto& v = vmain();
+  auto dst1 = v.makeReg();
+
+  v << loadl{baseReg[ArrayData::offsetofSize()], dst1};
+  v << testl{dst1, dst1};
 
-  v << cmpbim{ArrayData::kNvtwKind, baseReg[ArrayData::offsetofKind()]};
-  unlikelyIfThenElse(v, vcold(), CC_Z,
+  unlikelyCond(v, vcold(), CC_S, dstReg,
     [&](Vout& v) {
-      cgCallNative(v, inst);
+      auto dst2 = v.makeReg();
+      cgCallHelper(v, CppCall::method(&ArrayData::vsize),
+                   callDest(dst2), SyncOptions::kNoSyncPoint,
+                   argGroup().ssa(0/*base*/));
+      return dst2;
     },
     [&](Vout& v) {
-      v << loadl{baseReg[ArrayData::offsetofSize()], dstReg};
+       return dst1;
     }
   );
 }
Index: hhvm/hphp/runtime/vm/jit/ir.h
===================================================================
--- hhvm.orig/hphp/runtime/vm/jit/ir.h
+++ hhvm/hphp/runtime/vm/jit/ir.h
@@ -260,7 +260,7 @@ O(ConvObjToArr,                 D(Arr), S(Obj),               Er|N|PRc|CRc|K) \
 O(ConvStrToArr,                 D(Arr), S(Str),                  NNT|PRc|CRc) \
 O(ConvCellToArr,                D(Arr), S(Cell),              Er|N|PRc|CRc|K) \
                                                                               \
-O(ConvArrToBool,               D(Bool), S(Arr),                           NF) \
+O(ConvArrToBool,               D(Bool), S(Arr),                          NNT) \
 O(ConvDblToBool,               D(Bool), S(Dbl),                            C) \
 O(ConvIntToBool,               D(Bool), S(Int),                            C) \
 O(ConvStrToBool,               D(Bool), S(Str),                          NNT) \
Index: hhvm/hphp/test/slow/array/empty-globals.php
===================================================================
--- hhvm.orig/hphp/test/slow/array/empty-globals.php
+++ hhvm/hphp/test/slow/array/empty-globals.php
@@ -6,7 +6,6 @@ function main() {
   }
 
   var_dump($g);
-  // This will say "true", which is intentionally divergent from PHP5.
   var_dump((bool)$g);
 }

Index: hhvm/hphp/test/slow/array/empty-globals.php.expect
===================================================================
--- hhvm.orig/hphp/test/slow/array/empty-globals.php.expect
+++ hhvm/hphp/test/slow/array/empty-globals.php.expect
@@ -1,3 +1,3 @@
 array(0) {
 }
-bool(true)
+bool(false)
Index: hhvm/hphp/test/slow/ext_ezc_test/count-proxyarray.php
===================================================================
--- /dev/null
+++ hhvm/hphp/test/slow/ext_ezc_test/count-proxyarray.php
@@ -0,0 +1,12 @@
+<?php
+
+// Ensure that count() and conversion to boolean work with proxy arrays
+
+$x = ezc_create_cloneable_in_array();
+print count($x) . "\n";
+ezc_call(
+	function( $x ) {
+		print $x ? "true\n" : "false\n";
+	},
+	array()
+);
Index: hhvm/hphp/test/slow/ext_ezc_test/count-proxyarray.php.expectf
===================================================================
--- /dev/null
+++ hhvm/hphp/test/slow/ext_ezc_test/count-proxyarray.php.expectf
@@ -0,0 +1,2 @@
+1
+false
